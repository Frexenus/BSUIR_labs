# -*- coding: utf-8 -*-
"""ml2-l4-export.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LKkg5WnorxBhSy6FyonzHrSND1LR4N50
"""

# Commented out IPython magic to ensure Python compatibility.
# try:
  # # Colab only
# #   %tensorflow_version 2.x
# except Exception:
    # pass

from __future__ import absolute_import, division, print_function, unicode_literals

# TensorFlow и tf.keras
import tensorflow as tf
from tensorflow import keras

# Вспомогательные библиотеки
import numpy as np
import matplotlib.pyplot as plt

print(tf.__version__)

# Commented out IPython magic to ensure Python compatibility.
# These are all the modules we'll be using later. Make sure you can import them
# before proceeding further.
import matplotlib.pyplot as plt
import numpy as np
import os
import sys
import tarfile
from IPython.display import display, Image
from scipy import ndimage
from sklearn.linear_model import LogisticRegression
from six.moves.urllib.request import urlretrieve
from six.moves import cPickle as pickle
import urllib.request
from scipy.io import loadmat

# Config the matlotlib backend as plotting inline in IPython
# %matplotlib inline

last_percent_reported = None
        
def maybe_download(url, filename, force=False):
  """Download a file if not present, and make sure it's the right size."""
  if force or not os.path.exists(filename):
    print('Attempting to download:', filename) 
    filename, _ = urlretrieve(url + filename, filename)
    print('\nDownload Complete!')
  statinfo = os.stat(filename)
  return filename

print("1")
train_filename, _ = urllib.request.urlretrieve('http://ufldl.stanford.edu/housenumbers/train_32x32.mat', 'train_32x32.mat')
test_filename, _ = urllib.request.urlretrieve('http://ufldl.stanford.edu/housenumbers/test_32x32.mat', 'test_32x32.mat')

train_filename

def maybe_extract(filename, force=False):
    return loadmat(filename)

trainraw = maybe_extract(train_filename[0])
testraw = maybe_extract(test_filename[0])
print("2")
train_images, train_labels, test_images, test_labels = trainraw["X"], trainraw["y"], testraw["X"], testraw["y"]

train_images = np.asarray(train_images)
test_images = np.asarray(test_images)
train_labels = np.asarray(train_labels)
test_labels = np.asarray(test_labels)

train_images = np.moveaxis(train_images, -1, 0)
test_images  = np.moveaxis(test_images, -1, 0)

train_labels = np.where(train_labels==10, 0, train_labels)
test_labels = np.where(test_labels==10, 0, test_labels)

plt.imshow(train_images[3])
plt.colorbar()
# plt.grid(False)
plt.show()

train_images = train_images / 255.0
test_images = test_images / 255.0

plt.figure(figsize=(10,10))
for i in range(25):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(train_images[i])
    plt.xlabel(train_labels[i])
plt.show()
print("3")
model = tf.keras.models.Sequential()
model.add(tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))
model.add(tf.keras.layers.MaxPooling2D((2, 2)))
model.add(tf.keras.layers.Conv2D(64, (3, 3), activation='relu'))
model.add(tf.keras.layers.MaxPooling2D((2, 2)))
model.add(tf.keras.layers.Conv2D(64, (3, 3), activation='relu'))
model.add(tf.keras.layers.Flatten())
model.add(tf.keras.layers.Dense(64, activation='relu'))
model.add(tf.keras.layers.Dense(10))
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])


print("4")
model.fit(train_images, train_labels, epochs=10)

test_loss, test_acc = model.evaluate(test_images,  test_labels, verbose=2)
print('\nТочность данной нейронной сети:', test_acc)

tf.saved_model.save(model, '../model2/')

# restore
# newModel = tf.keras.models.load_model('/tmp/keipa/')
# newModel.evaluate(test_images,  test_labels, verbose=2)
# print('\nТочность данной нейронной сети:', test_acc)

# !zip -r /tmp/keipa.zip /tmp/keipa
# from google.colab import files
# files.download("/tmp/keipa.zip")

