Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    CONST
    TO
    COMMA
    FOR
    AND
    DOWNTO
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> var begin
Rule 2     var -> VAR declare
Rule 3     begin -> BEGIN body END POINT
Rule 4     declare -> declaration declare
Rule 5     declare -> empty
Rule 6     block -> BEGIN body END SEMICOLON
Rule 7     body -> expression
Rule 8     expression -> assignment body
Rule 9     expression -> if body
Rule 10    expression -> function body
Rule 11    expression -> empty
Rule 12    expression -> while body
Rule 13    declaration -> IDENTIFIER COLON type SEMICOLON
Rule 14    type -> TYPE_STRING
Rule 15    type -> TYPE_INTEGER
Rule 16    type -> TYPE_REAL
Rule 17    empty -> <empty>
Rule 18    assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression
Rule 19    assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
Rule 20    arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression
Rule 21    arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression
Rule 22    arithmetic_expression -> IDENTIFIER MUL arithmetic_expression
Rule 23    arithmetic_expression -> IDENTIFIER DIV arithmetic_expression
Rule 24    arithmetic_expression -> NUMBER PLUS arithmetic_expression
Rule 25    arithmetic_expression -> NUMBER MINUS arithmetic_expression
Rule 26    arithmetic_expression -> NUMBER MUL arithmetic_expression
Rule 27    arithmetic_expression -> NUMBER DIV arithmetic_expression
Rule 28    arithmetic_expression -> FLOAT_NUMBER
Rule 29    arithmetic_expression -> NUMBER
Rule 30    arithmetic_expression -> IDENTIFIER
Rule 31    arithmetic_expression -> STRING
Rule 32    function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
Rule 33    function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
Rule 34    function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
Rule 35    predicate -> IDENTIFIER EQUALITY arithmetic_expression
Rule 36    predicate -> NUMBER EQUALITY arithmetic_expression
Rule 37    predicate -> IDENTIFIER NON_EQUALITY arithmetic_expression
Rule 38    predicate -> NUMBER NON_STRICT_COMPARISON arithmetic_expression
Rule 39    predicate -> IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression
Rule 40    predicate -> NUMBER NON_EQUALITY arithmetic_expression
Rule 41    predicate -> NUMBER COMPARISON arithmetic_expression
Rule 42    predicate -> NUMBER
Rule 43    predicate -> IDENTIFIER
Rule 44    while -> WHILE predicate DO block
Rule 45    if -> IF predicate THEN block
Rule 46    if -> IF predicate THEN expression

Terminals, with rules where they appear

AND                  : 
ASSIGNMENT           : 18 19
BEGIN                : 3 6
CLOSE_BRACKET        : 32 33 34
COLON                : 13
COMMA                : 
COMPARISON           : 41
CONST                : 
DIV                  : 23 27
DO                   : 44
DOWNTO               : 
END                  : 3 6
EQUALITY             : 35 36
FLOAT_NUMBER         : 28
FOR                  : 
IDENTIFIER           : 13 18 19 20 21 22 23 30 33 34 35 37 39 43
IF                   : 45 46
INC                  : 34
MINUS                : 21 25
MUL                  : 22 26
NON_EQUALITY         : 37 40
NON_STRICT_COMPARISON : 38 39
NUMBER               : 24 25 26 27 29 36 38 40 41 42
OPEN_BRACKET         : 32 33 34
OR                   : 
PLUS                 : 20 24
POINT                : 3
READLN               : 33
SEMICOLON            : 6 13 19 32 33 34
STRING               : 31
THEN                 : 45 46
TO                   : 
TYPE_INTEGER         : 15
TYPE_REAL            : 16
TYPE_STRING          : 14
VAR                  : 2
WHILE                : 44
WRITELN              : 32
error                : 

Nonterminals, with rules where they appear

arithmetic_expression : 18 19 20 21 22 23 24 25 26 27 32 35 36 37 38 39 40 41
assignment           : 8
begin                : 1
block                : 44 45
body                 : 3 6 8 9 10 12
declaration          : 4
declare              : 2 4
empty                : 5 11
expression           : 7 46
function             : 10
if                   : 9
predicate            : 44 45 46
program              : 0
type                 : 13
var                  : 1
while                : 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . var begin
    (2) var -> . VAR declare

    VAR             shift and go to state 2

    var                            shift and go to state 1
    program                        shift and go to state 3

state 1

    (1) program -> var . begin
    (3) begin -> . BEGIN body END POINT

    BEGIN           shift and go to state 5

    begin                          shift and go to state 4

state 2

    (2) var -> VAR . declare
    (4) declare -> . declaration declare
    (5) declare -> . empty
    (13) declaration -> . IDENTIFIER COLON type SEMICOLON
    (17) empty -> .

    IDENTIFIER      shift and go to state 7
    BEGIN           reduce using rule 17 (empty -> .)

    declare                        shift and go to state 8
    empty                          shift and go to state 9
    declaration                    shift and go to state 6

state 3

    (0) S' -> program .



state 4

    (1) program -> var begin .

    $end            reduce using rule 1 (program -> var begin .)


state 5

    (3) begin -> BEGIN . body END POINT
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

    body                           shift and go to state 15
    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 6

    (4) declare -> declaration . declare
    (4) declare -> . declaration declare
    (5) declare -> . empty
    (13) declaration -> . IDENTIFIER COLON type SEMICOLON
    (17) empty -> .

    IDENTIFIER      shift and go to state 7
    BEGIN           reduce using rule 17 (empty -> .)

    declare                        shift and go to state 23
    empty                          shift and go to state 9
    declaration                    shift and go to state 6

state 7

    (13) declaration -> IDENTIFIER . COLON type SEMICOLON

    COLON           shift and go to state 24


state 8

    (2) var -> VAR declare .

    BEGIN           reduce using rule 2 (var -> VAR declare .)


state 9

    (5) declare -> empty .

    BEGIN           reduce using rule 5 (declare -> empty .)


state 10

    (10) expression -> function . body
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WRITELN         [ reduce using rule 17 (empty -> .) ]
  ! READLN          [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]

    function                       shift and go to state 10
    body                           shift and go to state 25
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 11

    (44) while -> WHILE . predicate DO block
    (35) predicate -> . IDENTIFIER EQUALITY arithmetic_expression
    (36) predicate -> . NUMBER EQUALITY arithmetic_expression
    (37) predicate -> . IDENTIFIER NON_EQUALITY arithmetic_expression
    (38) predicate -> . NUMBER NON_STRICT_COMPARISON arithmetic_expression
    (39) predicate -> . IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression
    (40) predicate -> . NUMBER NON_EQUALITY arithmetic_expression
    (41) predicate -> . NUMBER COMPARISON arithmetic_expression
    (42) predicate -> . NUMBER
    (43) predicate -> . IDENTIFIER

    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 27

    predicate                      shift and go to state 26

state 12

    (9) expression -> if . body
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WRITELN         [ reduce using rule 17 (empty -> .) ]
  ! READLN          [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]

    body                           shift and go to state 29
    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 13

    (18) assignment -> IDENTIFIER . ASSIGNMENT arithmetic_expression
    (19) assignment -> IDENTIFIER . ASSIGNMENT arithmetic_expression SEMICOLON

    ASSIGNMENT      shift and go to state 30


state 14

    (11) expression -> empty .

    END             reduce using rule 11 (expression -> empty .)
    IDENTIFIER      reduce using rule 11 (expression -> empty .)
    IF              reduce using rule 11 (expression -> empty .)
    WRITELN         reduce using rule 11 (expression -> empty .)
    READLN          reduce using rule 11 (expression -> empty .)
    INC             reduce using rule 11 (expression -> empty .)
    WHILE           reduce using rule 11 (expression -> empty .)


state 15

    (3) begin -> BEGIN body . END POINT

    END             shift and go to state 31


state 16

    (8) expression -> assignment . body
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WRITELN         [ reduce using rule 17 (empty -> .) ]
  ! READLN          [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]

    body                           shift and go to state 32
    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 17

    (32) function -> WRITELN . OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON

    OPEN_BRACKET    shift and go to state 33


state 18

    (45) if -> IF . predicate THEN block
    (46) if -> IF . predicate THEN expression
    (35) predicate -> . IDENTIFIER EQUALITY arithmetic_expression
    (36) predicate -> . NUMBER EQUALITY arithmetic_expression
    (37) predicate -> . IDENTIFIER NON_EQUALITY arithmetic_expression
    (38) predicate -> . NUMBER NON_STRICT_COMPARISON arithmetic_expression
    (39) predicate -> . IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression
    (40) predicate -> . NUMBER NON_EQUALITY arithmetic_expression
    (41) predicate -> . NUMBER COMPARISON arithmetic_expression
    (42) predicate -> . NUMBER
    (43) predicate -> . IDENTIFIER

    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 27

    predicate                      shift and go to state 34

state 19

    (33) function -> READLN . OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON

    OPEN_BRACKET    shift and go to state 35


state 20

    (12) expression -> while . body
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WRITELN         [ reduce using rule 17 (empty -> .) ]
  ! READLN          [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]

    body                           shift and go to state 36
    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 21

    (7) body -> expression .

    END             reduce using rule 7 (body -> expression .)
    IDENTIFIER      reduce using rule 7 (body -> expression .)
    IF              reduce using rule 7 (body -> expression .)
    WRITELN         reduce using rule 7 (body -> expression .)
    READLN          reduce using rule 7 (body -> expression .)
    INC             reduce using rule 7 (body -> expression .)
    WHILE           reduce using rule 7 (body -> expression .)


state 22

    (34) function -> INC . OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON

    OPEN_BRACKET    shift and go to state 37


state 23

    (4) declare -> declaration declare .

    BEGIN           reduce using rule 4 (declare -> declaration declare .)


state 24

    (13) declaration -> IDENTIFIER COLON . type SEMICOLON
    (14) type -> . TYPE_STRING
    (15) type -> . TYPE_INTEGER
    (16) type -> . TYPE_REAL

    TYPE_STRING     shift and go to state 38
    TYPE_INTEGER    shift and go to state 40
    TYPE_REAL       shift and go to state 39

    type                           shift and go to state 41

state 25

    (10) expression -> function body .

    END             reduce using rule 10 (expression -> function body .)
    IDENTIFIER      reduce using rule 10 (expression -> function body .)
    IF              reduce using rule 10 (expression -> function body .)
    WRITELN         reduce using rule 10 (expression -> function body .)
    READLN          reduce using rule 10 (expression -> function body .)
    INC             reduce using rule 10 (expression -> function body .)
    WHILE           reduce using rule 10 (expression -> function body .)


state 26

    (44) while -> WHILE predicate . DO block

    DO              shift and go to state 42


state 27

    (36) predicate -> NUMBER . EQUALITY arithmetic_expression
    (38) predicate -> NUMBER . NON_STRICT_COMPARISON arithmetic_expression
    (40) predicate -> NUMBER . NON_EQUALITY arithmetic_expression
    (41) predicate -> NUMBER . COMPARISON arithmetic_expression
    (42) predicate -> NUMBER .

    EQUALITY        shift and go to state 45
    NON_STRICT_COMPARISON shift and go to state 44
    NON_EQUALITY    shift and go to state 46
    COMPARISON      shift and go to state 43
    THEN            reduce using rule 42 (predicate -> NUMBER .)
    DO              reduce using rule 42 (predicate -> NUMBER .)


state 28

    (35) predicate -> IDENTIFIER . EQUALITY arithmetic_expression
    (37) predicate -> IDENTIFIER . NON_EQUALITY arithmetic_expression
    (39) predicate -> IDENTIFIER . NON_STRICT_COMPARISON arithmetic_expression
    (43) predicate -> IDENTIFIER .

    EQUALITY        shift and go to state 48
    NON_EQUALITY    shift and go to state 47
    NON_STRICT_COMPARISON shift and go to state 49
    THEN            reduce using rule 43 (predicate -> IDENTIFIER .)
    DO              reduce using rule 43 (predicate -> IDENTIFIER .)


state 29

    (9) expression -> if body .

    END             reduce using rule 9 (expression -> if body .)
    IDENTIFIER      reduce using rule 9 (expression -> if body .)
    IF              reduce using rule 9 (expression -> if body .)
    WRITELN         reduce using rule 9 (expression -> if body .)
    READLN          reduce using rule 9 (expression -> if body .)
    INC             reduce using rule 9 (expression -> if body .)
    WHILE           reduce using rule 9 (expression -> if body .)


state 30

    (18) assignment -> IDENTIFIER ASSIGNMENT . arithmetic_expression
    (19) assignment -> IDENTIFIER ASSIGNMENT . arithmetic_expression SEMICOLON
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 50

state 31

    (3) begin -> BEGIN body END . POINT

    POINT           shift and go to state 55


state 32

    (8) expression -> assignment body .

    END             reduce using rule 8 (expression -> assignment body .)
    IDENTIFIER      reduce using rule 8 (expression -> assignment body .)
    IF              reduce using rule 8 (expression -> assignment body .)
    WRITELN         reduce using rule 8 (expression -> assignment body .)
    READLN          reduce using rule 8 (expression -> assignment body .)
    INC             reduce using rule 8 (expression -> assignment body .)
    WHILE           reduce using rule 8 (expression -> assignment body .)


state 33

    (32) function -> WRITELN OPEN_BRACKET . arithmetic_expression CLOSE_BRACKET SEMICOLON
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 56

state 34

    (45) if -> IF predicate . THEN block
    (46) if -> IF predicate . THEN expression

    THEN            shift and go to state 57


state 35

    (33) function -> READLN OPEN_BRACKET . IDENTIFIER CLOSE_BRACKET SEMICOLON

    IDENTIFIER      shift and go to state 58


state 36

    (12) expression -> while body .

    END             reduce using rule 12 (expression -> while body .)
    IDENTIFIER      reduce using rule 12 (expression -> while body .)
    IF              reduce using rule 12 (expression -> while body .)
    WRITELN         reduce using rule 12 (expression -> while body .)
    READLN          reduce using rule 12 (expression -> while body .)
    INC             reduce using rule 12 (expression -> while body .)
    WHILE           reduce using rule 12 (expression -> while body .)


state 37

    (34) function -> INC OPEN_BRACKET . IDENTIFIER CLOSE_BRACKET SEMICOLON

    IDENTIFIER      shift and go to state 59


state 38

    (14) type -> TYPE_STRING .

    SEMICOLON       reduce using rule 14 (type -> TYPE_STRING .)


state 39

    (16) type -> TYPE_REAL .

    SEMICOLON       reduce using rule 16 (type -> TYPE_REAL .)


state 40

    (15) type -> TYPE_INTEGER .

    SEMICOLON       reduce using rule 15 (type -> TYPE_INTEGER .)


state 41

    (13) declaration -> IDENTIFIER COLON type . SEMICOLON

    SEMICOLON       shift and go to state 60


state 42

    (44) while -> WHILE predicate DO . block
    (6) block -> . BEGIN body END SEMICOLON

    BEGIN           shift and go to state 61

    block                          shift and go to state 62

state 43

    (41) predicate -> NUMBER COMPARISON . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 63

state 44

    (38) predicate -> NUMBER NON_STRICT_COMPARISON . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 64

state 45

    (36) predicate -> NUMBER EQUALITY . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 65

state 46

    (40) predicate -> NUMBER NON_EQUALITY . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 66

state 47

    (37) predicate -> IDENTIFIER NON_EQUALITY . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 67

state 48

    (35) predicate -> IDENTIFIER EQUALITY . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 68

state 49

    (39) predicate -> IDENTIFIER NON_STRICT_COMPARISON . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 69

state 50

    (18) assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .
    (19) assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression . SEMICOLON

    IDENTIFIER      reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    IF              reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    WRITELN         reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    READLN          reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    INC             reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    WHILE           reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    END             reduce using rule 18 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression .)
    SEMICOLON       shift and go to state 70


state 51

    (31) arithmetic_expression -> STRING .

    SEMICOLON       reduce using rule 31 (arithmetic_expression -> STRING .)
    IDENTIFIER      reduce using rule 31 (arithmetic_expression -> STRING .)
    IF              reduce using rule 31 (arithmetic_expression -> STRING .)
    WRITELN         reduce using rule 31 (arithmetic_expression -> STRING .)
    READLN          reduce using rule 31 (arithmetic_expression -> STRING .)
    INC             reduce using rule 31 (arithmetic_expression -> STRING .)
    WHILE           reduce using rule 31 (arithmetic_expression -> STRING .)
    END             reduce using rule 31 (arithmetic_expression -> STRING .)
    CLOSE_BRACKET   reduce using rule 31 (arithmetic_expression -> STRING .)
    DO              reduce using rule 31 (arithmetic_expression -> STRING .)
    THEN            reduce using rule 31 (arithmetic_expression -> STRING .)


state 52

    (24) arithmetic_expression -> NUMBER . PLUS arithmetic_expression
    (25) arithmetic_expression -> NUMBER . MINUS arithmetic_expression
    (26) arithmetic_expression -> NUMBER . MUL arithmetic_expression
    (27) arithmetic_expression -> NUMBER . DIV arithmetic_expression
    (29) arithmetic_expression -> NUMBER .

    PLUS            shift and go to state 71
    MINUS           shift and go to state 74
    MUL             shift and go to state 72
    DIV             shift and go to state 73
    SEMICOLON       reduce using rule 29 (arithmetic_expression -> NUMBER .)
    IDENTIFIER      reduce using rule 29 (arithmetic_expression -> NUMBER .)
    IF              reduce using rule 29 (arithmetic_expression -> NUMBER .)
    WRITELN         reduce using rule 29 (arithmetic_expression -> NUMBER .)
    READLN          reduce using rule 29 (arithmetic_expression -> NUMBER .)
    INC             reduce using rule 29 (arithmetic_expression -> NUMBER .)
    WHILE           reduce using rule 29 (arithmetic_expression -> NUMBER .)
    END             reduce using rule 29 (arithmetic_expression -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 29 (arithmetic_expression -> NUMBER .)
    DO              reduce using rule 29 (arithmetic_expression -> NUMBER .)
    THEN            reduce using rule 29 (arithmetic_expression -> NUMBER .)


state 53

    (28) arithmetic_expression -> FLOAT_NUMBER .

    SEMICOLON       reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    IDENTIFIER      reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    IF              reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    WRITELN         reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    READLN          reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    INC             reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    WHILE           reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    END             reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    CLOSE_BRACKET   reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    DO              reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)
    THEN            reduce using rule 28 (arithmetic_expression -> FLOAT_NUMBER .)


state 54

    (20) arithmetic_expression -> IDENTIFIER . PLUS arithmetic_expression
    (21) arithmetic_expression -> IDENTIFIER . MINUS arithmetic_expression
    (22) arithmetic_expression -> IDENTIFIER . MUL arithmetic_expression
    (23) arithmetic_expression -> IDENTIFIER . DIV arithmetic_expression
    (30) arithmetic_expression -> IDENTIFIER .

    PLUS            shift and go to state 75
    MINUS           shift and go to state 78
    MUL             shift and go to state 76
    DIV             shift and go to state 77
    SEMICOLON       reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    IF              reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    WRITELN         reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    READLN          reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    INC             reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    WHILE           reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    END             reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    CLOSE_BRACKET   reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    DO              reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)
    THEN            reduce using rule 30 (arithmetic_expression -> IDENTIFIER .)


state 55

    (3) begin -> BEGIN body END POINT .

    $end            reduce using rule 3 (begin -> BEGIN body END POINT .)


state 56

    (32) function -> WRITELN OPEN_BRACKET arithmetic_expression . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 79


state 57

    (45) if -> IF predicate THEN . block
    (46) if -> IF predicate THEN . expression
    (6) block -> . BEGIN body END SEMICOLON
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    BEGIN           shift and go to state 61
    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

  ! IDENTIFIER      [ reduce using rule 17 (empty -> .) ]
  ! IF              [ reduce using rule 17 (empty -> .) ]
  ! WRITELN         [ reduce using rule 17 (empty -> .) ]
  ! READLN          [ reduce using rule 17 (empty -> .) ]
  ! INC             [ reduce using rule 17 (empty -> .) ]
  ! WHILE           [ reduce using rule 17 (empty -> .) ]

    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    empty                          shift and go to state 14
    expression                     shift and go to state 80
    block                          shift and go to state 81
    if                             shift and go to state 12

state 58

    (33) function -> READLN OPEN_BRACKET IDENTIFIER . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 82


state 59

    (34) function -> INC OPEN_BRACKET IDENTIFIER . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 83


state 60

    (13) declaration -> IDENTIFIER COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 13 (declaration -> IDENTIFIER COLON type SEMICOLON .)
    BEGIN           reduce using rule 13 (declaration -> IDENTIFIER COLON type SEMICOLON .)


state 61

    (6) block -> BEGIN . body END SEMICOLON
    (7) body -> . expression
    (8) expression -> . assignment body
    (9) expression -> . if body
    (10) expression -> . function body
    (11) expression -> . empty
    (12) expression -> . while body
    (18) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression
    (19) assignment -> . IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON
    (45) if -> . IF predicate THEN block
    (46) if -> . IF predicate THEN expression
    (32) function -> . WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON
    (33) function -> . READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (34) function -> . INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON
    (17) empty -> .
    (44) while -> . WHILE predicate DO block

    IDENTIFIER      shift and go to state 13
    IF              shift and go to state 18
    WRITELN         shift and go to state 17
    READLN          shift and go to state 19
    INC             shift and go to state 22
    END             reduce using rule 17 (empty -> .)
    WHILE           shift and go to state 11

    body                           shift and go to state 84
    function                       shift and go to state 10
    assignment                     shift and go to state 16
    while                          shift and go to state 20
    expression                     shift and go to state 21
    empty                          shift and go to state 14
    if                             shift and go to state 12

state 62

    (44) while -> WHILE predicate DO block .

    IDENTIFIER      reduce using rule 44 (while -> WHILE predicate DO block .)
    IF              reduce using rule 44 (while -> WHILE predicate DO block .)
    WRITELN         reduce using rule 44 (while -> WHILE predicate DO block .)
    READLN          reduce using rule 44 (while -> WHILE predicate DO block .)
    INC             reduce using rule 44 (while -> WHILE predicate DO block .)
    WHILE           reduce using rule 44 (while -> WHILE predicate DO block .)
    END             reduce using rule 44 (while -> WHILE predicate DO block .)


state 63

    (41) predicate -> NUMBER COMPARISON arithmetic_expression .

    THEN            reduce using rule 41 (predicate -> NUMBER COMPARISON arithmetic_expression .)
    DO              reduce using rule 41 (predicate -> NUMBER COMPARISON arithmetic_expression .)


state 64

    (38) predicate -> NUMBER NON_STRICT_COMPARISON arithmetic_expression .

    THEN            reduce using rule 38 (predicate -> NUMBER NON_STRICT_COMPARISON arithmetic_expression .)
    DO              reduce using rule 38 (predicate -> NUMBER NON_STRICT_COMPARISON arithmetic_expression .)


state 65

    (36) predicate -> NUMBER EQUALITY arithmetic_expression .

    THEN            reduce using rule 36 (predicate -> NUMBER EQUALITY arithmetic_expression .)
    DO              reduce using rule 36 (predicate -> NUMBER EQUALITY arithmetic_expression .)


state 66

    (40) predicate -> NUMBER NON_EQUALITY arithmetic_expression .

    THEN            reduce using rule 40 (predicate -> NUMBER NON_EQUALITY arithmetic_expression .)
    DO              reduce using rule 40 (predicate -> NUMBER NON_EQUALITY arithmetic_expression .)


state 67

    (37) predicate -> IDENTIFIER NON_EQUALITY arithmetic_expression .

    THEN            reduce using rule 37 (predicate -> IDENTIFIER NON_EQUALITY arithmetic_expression .)
    DO              reduce using rule 37 (predicate -> IDENTIFIER NON_EQUALITY arithmetic_expression .)


state 68

    (35) predicate -> IDENTIFIER EQUALITY arithmetic_expression .

    THEN            reduce using rule 35 (predicate -> IDENTIFIER EQUALITY arithmetic_expression .)
    DO              reduce using rule 35 (predicate -> IDENTIFIER EQUALITY arithmetic_expression .)


state 69

    (39) predicate -> IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression .

    THEN            reduce using rule 39 (predicate -> IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression .)
    DO              reduce using rule 39 (predicate -> IDENTIFIER NON_STRICT_COMPARISON arithmetic_expression .)


state 70

    (19) assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .

    IDENTIFIER      reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    IF              reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    WRITELN         reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    READLN          reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    INC             reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    WHILE           reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)
    END             reduce using rule 19 (assignment -> IDENTIFIER ASSIGNMENT arithmetic_expression SEMICOLON .)


state 71

    (24) arithmetic_expression -> NUMBER PLUS . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 85

state 72

    (26) arithmetic_expression -> NUMBER MUL . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 86

state 73

    (27) arithmetic_expression -> NUMBER DIV . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 87

state 74

    (25) arithmetic_expression -> NUMBER MINUS . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 88

state 75

    (20) arithmetic_expression -> IDENTIFIER PLUS . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 89

state 76

    (22) arithmetic_expression -> IDENTIFIER MUL . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 90

state 77

    (23) arithmetic_expression -> IDENTIFIER DIV . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 91

state 78

    (21) arithmetic_expression -> IDENTIFIER MINUS . arithmetic_expression
    (20) arithmetic_expression -> . IDENTIFIER PLUS arithmetic_expression
    (21) arithmetic_expression -> . IDENTIFIER MINUS arithmetic_expression
    (22) arithmetic_expression -> . IDENTIFIER MUL arithmetic_expression
    (23) arithmetic_expression -> . IDENTIFIER DIV arithmetic_expression
    (24) arithmetic_expression -> . NUMBER PLUS arithmetic_expression
    (25) arithmetic_expression -> . NUMBER MINUS arithmetic_expression
    (26) arithmetic_expression -> . NUMBER MUL arithmetic_expression
    (27) arithmetic_expression -> . NUMBER DIV arithmetic_expression
    (28) arithmetic_expression -> . FLOAT_NUMBER
    (29) arithmetic_expression -> . NUMBER
    (30) arithmetic_expression -> . IDENTIFIER
    (31) arithmetic_expression -> . STRING

    IDENTIFIER      shift and go to state 54
    NUMBER          shift and go to state 52
    FLOAT_NUMBER    shift and go to state 53
    STRING          shift and go to state 51

    arithmetic_expression          shift and go to state 92

state 79

    (32) function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 93


state 80

    (46) if -> IF predicate THEN expression .

    IDENTIFIER      reduce using rule 46 (if -> IF predicate THEN expression .)
    IF              reduce using rule 46 (if -> IF predicate THEN expression .)
    WRITELN         reduce using rule 46 (if -> IF predicate THEN expression .)
    READLN          reduce using rule 46 (if -> IF predicate THEN expression .)
    INC             reduce using rule 46 (if -> IF predicate THEN expression .)
    WHILE           reduce using rule 46 (if -> IF predicate THEN expression .)
    END             reduce using rule 46 (if -> IF predicate THEN expression .)


state 81

    (45) if -> IF predicate THEN block .

    IDENTIFIER      reduce using rule 45 (if -> IF predicate THEN block .)
    IF              reduce using rule 45 (if -> IF predicate THEN block .)
    WRITELN         reduce using rule 45 (if -> IF predicate THEN block .)
    READLN          reduce using rule 45 (if -> IF predicate THEN block .)
    INC             reduce using rule 45 (if -> IF predicate THEN block .)
    WHILE           reduce using rule 45 (if -> IF predicate THEN block .)
    END             reduce using rule 45 (if -> IF predicate THEN block .)


state 82

    (33) function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 94


state 83

    (34) function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 95


state 84

    (6) block -> BEGIN body . END SEMICOLON

    END             shift and go to state 96


state 85

    (24) arithmetic_expression -> NUMBER PLUS arithmetic_expression .

    SEMICOLON       reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    IDENTIFIER      reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    IF              reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    WRITELN         reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    READLN          reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    INC             reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    WHILE           reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    END             reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    DO              reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)
    THEN            reduce using rule 24 (arithmetic_expression -> NUMBER PLUS arithmetic_expression .)


state 86

    (26) arithmetic_expression -> NUMBER MUL arithmetic_expression .

    SEMICOLON       reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    IDENTIFIER      reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    IF              reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    WRITELN         reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    READLN          reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    INC             reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    WHILE           reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    END             reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    DO              reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)
    THEN            reduce using rule 26 (arithmetic_expression -> NUMBER MUL arithmetic_expression .)


state 87

    (27) arithmetic_expression -> NUMBER DIV arithmetic_expression .

    SEMICOLON       reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    IDENTIFIER      reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    IF              reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    WRITELN         reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    READLN          reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    INC             reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    WHILE           reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    END             reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    DO              reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)
    THEN            reduce using rule 27 (arithmetic_expression -> NUMBER DIV arithmetic_expression .)


state 88

    (25) arithmetic_expression -> NUMBER MINUS arithmetic_expression .

    SEMICOLON       reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    IDENTIFIER      reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    IF              reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    WRITELN         reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    READLN          reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    INC             reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    WHILE           reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    END             reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    DO              reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)
    THEN            reduce using rule 25 (arithmetic_expression -> NUMBER MINUS arithmetic_expression .)


state 89

    (20) arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .

    SEMICOLON       reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    IDENTIFIER      reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    IF              reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    WRITELN         reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    READLN          reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    INC             reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    WHILE           reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    END             reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    DO              reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)
    THEN            reduce using rule 20 (arithmetic_expression -> IDENTIFIER PLUS arithmetic_expression .)


state 90

    (22) arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .

    SEMICOLON       reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    IDENTIFIER      reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    IF              reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    WRITELN         reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    READLN          reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    INC             reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    WHILE           reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    END             reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    DO              reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)
    THEN            reduce using rule 22 (arithmetic_expression -> IDENTIFIER MUL arithmetic_expression .)


state 91

    (23) arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .

    SEMICOLON       reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    IDENTIFIER      reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    IF              reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    WRITELN         reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    READLN          reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    INC             reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    WHILE           reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    END             reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    DO              reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)
    THEN            reduce using rule 23 (arithmetic_expression -> IDENTIFIER DIV arithmetic_expression .)


state 92

    (21) arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .

    SEMICOLON       reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    IDENTIFIER      reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    IF              reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    WRITELN         reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    READLN          reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    INC             reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    WHILE           reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    END             reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    CLOSE_BRACKET   reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    DO              reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)
    THEN            reduce using rule 21 (arithmetic_expression -> IDENTIFIER MINUS arithmetic_expression .)


state 93

    (32) function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .

    IDENTIFIER      reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    WRITELN         reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    READLN          reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    INC             reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)
    END             reduce using rule 32 (function -> WRITELN OPEN_BRACKET arithmetic_expression CLOSE_BRACKET SEMICOLON .)


state 94

    (33) function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .

    IDENTIFIER      reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    WRITELN         reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    READLN          reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    INC             reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    END             reduce using rule 33 (function -> READLN OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)


state 95

    (34) function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .

    IDENTIFIER      reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    WRITELN         reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    READLN          reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    INC             reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)
    END             reduce using rule 34 (function -> INC OPEN_BRACKET IDENTIFIER CLOSE_BRACKET SEMICOLON .)


state 96

    (6) block -> BEGIN body END . SEMICOLON

    SEMICOLON       shift and go to state 97


state 97

    (6) block -> BEGIN body END SEMICOLON .

    IDENTIFIER      reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    IF              reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    WRITELN         reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    READLN          reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    INC             reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    WHILE           reduce using rule 6 (block -> BEGIN body END SEMICOLON .)
    END             reduce using rule 6 (block -> BEGIN body END SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 10 resolved as shift
WARNING: shift/reduce conflict for IF in state 10 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 10 resolved as shift
WARNING: shift/reduce conflict for READLN in state 10 resolved as shift
WARNING: shift/reduce conflict for INC in state 10 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 10 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 12 resolved as shift
WARNING: shift/reduce conflict for IF in state 12 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 12 resolved as shift
WARNING: shift/reduce conflict for READLN in state 12 resolved as shift
WARNING: shift/reduce conflict for INC in state 12 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 12 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 16 resolved as shift
WARNING: shift/reduce conflict for IF in state 16 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 16 resolved as shift
WARNING: shift/reduce conflict for READLN in state 16 resolved as shift
WARNING: shift/reduce conflict for INC in state 16 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 16 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 20 resolved as shift
WARNING: shift/reduce conflict for READLN in state 20 resolved as shift
WARNING: shift/reduce conflict for INC in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 57 resolved as shift
WARNING: shift/reduce conflict for IF in state 57 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 57 resolved as shift
WARNING: shift/reduce conflict for READLN in state 57 resolved as shift
WARNING: shift/reduce conflict for INC in state 57 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 57 resolved as shift
