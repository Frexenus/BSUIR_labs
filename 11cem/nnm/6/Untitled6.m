P = [1 2 3]; % входы НС регрессии
T = [3.0 5.1 4.8]; % выходы НС регрессии

spread = 0.8; % установка разброса радиальных базисных функций
net = newgrnn(P, T, spread); % создание НС регрессии
A = sim (net, P); % имитация работы НС регрессии

plot(P, T, '.', 'markersize', 30); % изображение аппроксимируемой функции

plot(P, A, '.', 'markersize', 30, 'color', [1 0 0]); % изображение работы необученной НС регрессии

cla reset; % очистка координатных осей
p = 4.5; % установка нового входа НС регрессии
a = sim(net, p); % получение отклика НС регрессии
plot(P, T, 'markersize', 30); % изображение аппроксимируемой функции

axis([0 9 3 7]); % установка диапазонов осей X и Y
hold on; % включение режима добавления графиков
plot(p, a, '.', 'markersize', 30, 'color', [1 0 0]); % изображение отклика НС регрессии на вход р
title( 'Новый входной вектор '); % написать заголовок графика
xlabel('P и р'); % пометить ось X
ylabel('T и а'); % пометить ось Y
cla reset; % очистить координатную сетку
P2 = 0:2:9; % определить последовательность входов Р2

A2 = sim(net, P2); % получить отклик НС регрессии на последовательность входов Р2

plot(P2, A2, 'linewidth', 4, 'color', [1 0 0]); % отклик НС регрессии

hold on; % включить режим добавления графиков
plot(P, T, '.', 'markersize', 30); % изобразить аппроксимируемую функцию
axis([0 9 3 5.5]); % установить диапазон осей
title('Аппроксимируемая функция'); % озаглавить график
xlabel('P и Р2 '); % пометить ось X
ylabel('T и А2 '); % пометить ось Y

p = -4:2:4; % определение диапазона значений радиальной базисной функции
a = radbas(p); % вычисление радиальной базисной функции на диапазоне р
hold on;
plot(p, a); % изображение РБФ
title('Радиальная базисная функция'); % озаглавить график
xlabel('Вход р'); % пометить ось X
ylabel('Выход а '); % пометить ось Y

P = -1:0.1:1;
T = [-.6662 -.3766 -.1129 .2111 .6565 .3301 .3649 .2006 -.1913 -.3994 -.5022 -.4531 -.1133 .0866 .3333 .4955 .3488 .2833 -.1112 -.6685 -.3255];

hold on;
plot(P, T, '*'); % изображение аппроксимируемой функции
title('Обучающая выборка'); % озаглавить график
xlabel('Входной вектор P'); % пометить ось X
ylabel('Вектор T'); % пометить ось Y

e = 0,02; % целевой среднеквадратичной ошибки
sp = 1; % величина разброса радиальной базисной нейронной сети
net = newrb(P, T, e, sp); % создание радиальной базисной сети
X = -1 : .01 : 1; % определение вектора входов

Y = sim (net, X); % формирование отклика Y
hold on; % включение режима добавления графика
plot(X, Y); % изображение результатов аппроксимации
hold off; % отключение режима добавления графика



x1 = -1.0; x2 = +1.0; y1 = -1.5; y2 = +1.5;
nx = 30; ny =30;

step_x = (x2-x1)/(nx-1); step_y = (y2-y1)/(ny-1);
step_min = min(step_x,step_y);
[x,y] = meshgrid([x1:step_x:x2], [y1:step_y:y2]);
z = exp(x.^2).*cos(-y.^3);
surf(x,y,z)
pause;
xx = reshape(x,1,nx*ny);
yy = reshape(y,1,nx*ny);
zz = exp(xx.^2).*cos(-yy.^3);
p = [xx; yy];
t = zz;
goal = 0.05;
spread = 1.0*step_min;
net = newrb(p,t, goal,spread);
net.layers{1}.size
b = sim(net,p);
[zz' b']
c = reshape(b,ny,nx);
surf(x,y,c)

P = [1 2 3 4 5 6 7 ]; % определение входов
V = [1 1 3 3 2 1 1]; % определение желаемых выходов
T = ind2vec (V); % конвертирование индексов в векторы, содержащие 1 в индексных позициях
net = newpnn(P, T); % создание вероятностной НС
Y = sim (net, P); % имитация работы вероятностной НС
W = vec2ind (Y); % конвертирование номеров классов в векторы